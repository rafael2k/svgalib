Author: Matthew Garrett <mjg59@srcf.ucam.org>
Author: Guillem Jover <guillem@debian.org>

Index: b/src/Makefile
===================================================================
--- a/src/Makefile
+++ b/src/Makefile
@@ -189,7 +189,8 @@ ifdef INCLUDE_APM_DRIVER
 endif
 ifdef INCLUDE_VESA_DRIVER
   VGA_DEFINES +=-DINCLUDE_VESA_DRIVER
-  DRIVERS += vesa.o lrmi.o
+  DRIVERS += vesa.o
+  SHLIBLIBS += -lx86
   ifdef INCLUDE_VESA_DRIVER_TEST
     VGA_DEFINES += -DINCLUDE_VESA_DRIVER_TEST
   endif
Index: b/src/vga.c
===================================================================
--- a/src/vga.c
+++ b/src/vga.c
@@ -4205,12 +4205,6 @@ static char *process_option(int command,
         break;
     case 66: /* cpu type */
         ptr = strtok(NULL, " ");
-#ifdef INCLUDE_VESA_DRIVER
-        if(ptr!=NULL){
-            j = atoi(ptr);
-            __svgalib_lrmi_cpu_type=j;
-        };
-#endif
         break;
     case 67:
         __svgalib_neolibretto100=1;
Index: b/lrmi-0.6m/Makefile
===================================================================
--- a/lrmi-0.6m/Makefile
+++ b/lrmi-0.6m/Makefile
@@ -1,7 +1,5 @@
 CFLAGS = -g -Wall
 
-sources = lrmi.c
-objects = lrmi.o
 all = vbetest mode3 vga_reset vbemodeinfo
 
 %.o: %.c
@@ -9,17 +7,17 @@ all = vbetest mode3 vga_reset vbemodeinf
 
 all: $(all)
 
-vbetest: vbetest.c lrmi.o
-	$(CC) $(CPPFLAGS) $(CFLAGS) -o $@ $^
+vbetest: vbetest.c
+	$(CC) $(CPPFLAGS) $(CFLAGS) -o $@ $^ -lx86
 
-mode3: mode3.c lrmi.o
-	$(CC) $(CFLAGS) -o $@ $^
+mode3: mode3.c
+	$(CC) $(CFLAGS) -o $@ $^ -lx86
 
-vbemodeinfo: vbemodeinfo.c lrmi.o
-	$(CC) $(CFLAGS) -o $@ $^
+vbemodeinfo: vbemodeinfo.c
+	$(CC) $(CFLAGS) -o $@ $^ -lx86
 
-vga_reset: vga_reset.c lrmi.o
-	$(CC) $(CFLAGS) -o $@ $^
+vga_reset: vga_reset.c
+	$(CC) $(CFLAGS) -o $@ $^ -lx86
 
 install: mode3 vga_reset
 	install mode3 /sbin
Index: b/Makefile
===================================================================
--- a/Makefile
+++ b/Makefile
@@ -188,10 +188,12 @@ ifeq (y, $(IO_DRIVERS))
 	@echo "savetextmode:     Script that saves textmode information used by 'textmode'."
 	@cp utils/savetextmode $(bindir)
 endif
+ifeq (y, $(LIBX86))
 	@echo "mode3:            Restore textmode by setting VESA mode 3."
 	@cp lrmi-0.6m/mode3 $(bindir)
 	@echo "vga_reset:        Restore textmode by resetting graphic board."
 	@cp lrmi-0.6m/vga_reset $(bindir)
+endif
 	@echo "Installing keymap utilities in $(bindir):"
 	@echo "svgakeymap:       Perl script that generates scancode conversion maps."
 	@cp utils/svgakeymap $(bindir)
@@ -405,7 +407,7 @@ ifeq (y, $(IO_DRIVERS))
 endif
 
 lrmi:
-ifneq (y, $(NO_ASM))
+ifeq (y, $(LIBX86))
 	(cd lrmi-0.6m;\
 	$(MAKE))
 endif
Index: b/Makefile.cfg
===================================================================
--- a/Makefile.cfg
+++ b/Makefile.cfg
@@ -63,6 +63,10 @@ ifneq (,$(findstring $(arch),i386 x86_64
 IO_DRIVERS = y
 endif
 
+ifneq (,$(findstring $(arch),i386 x86_64))
+LIBX86 = y
+endif
+
 # Uncomment this if you want root processes to be able to always get a new
 # VC. Alas, some games misuse suid root privs and become root, svgalib cannot
 # detect this and will allow Joe blow user to open a new virtual VC. If this
@@ -151,7 +155,9 @@ INCLUDE_CHIPS_DRIVER = y
 INCLUDE_APM_DRIVER = y
 INCLUDE_NV3_DRIVER = y
 INCLUDE_ET6000_DRIVER = y
+ifeq (y, $(LIBX86))
 INCLUDE_VESA_DRIVER = y
+endif
 INCLUDE_MX_DRIVER = y
 INCLUDE_PARADISE_DRIVER = y
 INCLUDE_RAGE_DRIVER = y
Index: b/src/vesa.c
===================================================================
--- a/src/vesa.c
+++ b/src/vesa.c
@@ -17,7 +17,7 @@
 #include "vgaregs.h"
 #include "interface.h"
 #include "accel.h"
-#include "lrmi.h"
+#include <libx86.h>
 #include "vbe.h"
 #define VESAREG_SAVE(i) (VGA_TOTAL_REGS+i)
 #define VESA_TOTAL_REGS (VGA_TOTAL_REGS + 4024)
@@ -52,13 +52,13 @@ static void vesa_setpage(int page)
 vesa_r.eax=0x4f05;
 vesa_r.ebx=0;
 vesa_r.edx=page*64/vesa_granularity;
-__svgalib_LRMI_int(0x10,&vesa_r);
+LRMI_int(0x10,&vesa_r);
 
 if(vesa_read_write){
    vesa_r.eax=0x4f05;
    vesa_r.ebx=1;
    vesa_r.edx=page*64/vesa_granularity;
-   __svgalib_LRMI_int(0x10,&vesa_r);
+   LRMI_int(0x10,&vesa_r);
 };
 }
 
@@ -102,7 +102,7 @@ static void vesa_getmodeinfo(int mode, v
     vesa_r.es = (unsigned int)vesa_data.mode >> 4;
     vesa_r.edi = (unsigned int)vesa_data.mode & 0xf;
 
-    if (!__svgalib_LRMI_int(0x10, &vesa_r)) {
+    if (!LRMI_int(0x10, &vesa_r)) {
        fprintf(stderr, "Can't get mode info (vm86 failure)\n");
        return;
     }
@@ -119,7 +119,7 @@ static int vesa_saveregs(unsigned char r
   vesa_r.es=((long)buf)>>4;
   vesa_r.edx=1;
   vesa_r.ecx=__svgalib_VESA_savebitmap;
-  __svgalib_LRMI_int(0x10,&vesa_r);
+  LRMI_int(0x10,&vesa_r);
   memcpy(&regs[VGA_TOTAL_REGS],buf,vesa_regs_size);  
     return vesa_regs_size;
 }
@@ -137,7 +137,7 @@ static void vesa_setregs(const unsigned 
   vesa_r.es=((long)buf)>>4;
   vesa_r.edx=2;
   vesa_r.ecx=__svgalib_VESA_savebitmap;
-  __svgalib_LRMI_int(0x10,&vesa_r);
+  LRMI_int(0x10,&vesa_r);
 }
 
 
@@ -179,7 +179,7 @@ static int vesa_setmode(int mode, int pr
         if(__svgalib_vesatext){
             vesa_r.eax=0x4f02; /* make sure we are in a regular VGA mode before we start */
             vesa_r.ebx=__svgalib_VESA_textmode;    /* without this, if we start in SVGA mode the result might */
-            __svgalib_LRMI_int(0x10,&vesa_r); /* be something weird */
+            LRMI_int(0x10,&vesa_r); /* be something weird */
         };
 	return __svgalib_vga_driverspecs.setmode(mode, prv_mode);
     }
@@ -187,13 +187,13 @@ static int vesa_setmode(int mode, int pr
     vesa_r.eax=0x4f02;
     vesa_r.ebx=SVGALIB_VESA[mode]|0x8000|(vesa_is_linear*0x4000);
     vesa_last_mode_set=vesa_r.ebx;
-    __svgalib_LRMI_int(0x10,&vesa_r);
+    LRMI_int(0x10,&vesa_r);
 
     vesa_r.eax = 0x4f01;
     vesa_r.ecx=SVGALIB_VESA[mode];
     vesa_r.es = (unsigned int)vesa_data.mode >> 4;
     vesa_r.edi = (unsigned int)vesa_data.mode&0xf;    
-    __svgalib_LRMI_int(0x10, &vesa_r);
+    LRMI_int(0x10, &vesa_r);
     vesa_logical_width=vesa_data.mode->bytes_per_scanline;
     vesa_bpp=(vesa_data.mode->bits_per_pixel+7)/8;
     if(vesa_logical_width==0) vesa_logical_width=vesa_bpp*vesa_data.mode->x_resolution;
@@ -239,15 +239,15 @@ static int vesa_test(void)
     }
     
     lrmi_inited=1;
-    __svgalib_LRMI_init();
-    vesa_data.info = __svgalib_LRMI_alloc_real(sizeof(struct vbe_info_block)
+    LRMI_init();
+    vesa_data.info = LRMI_alloc_real(sizeof(struct vbe_info_block)
 	 + sizeof(struct vbe_mode_info_block));
     vesa_data.mode = (struct vbe_mode_info_block *)(vesa_data.info + 1);
     vesa_r.eax = 0x4f00;
     vesa_r.es = (unsigned int)vesa_data.info >> 4;
     vesa_r.edi = 0;
 
-    __svgalib_LRMI_int(0x10, &vesa_r);
+    LRMI_int(0x10, &vesa_r);
     if (vesa_r.eax!=0x4f) return 0;
     return !vesa_init(0,0,0);
 }
@@ -259,14 +259,14 @@ static void vesa_setrdpage(int page)
 vesa_r.eax=0x4f05;
 vesa_r.ebx=vesa_read_window;
 vesa_r.edx=page*64/vesa_granularity;
-__svgalib_LRMI_int(0x10,&vesa_r);
+LRMI_int(0x10,&vesa_r);
 }
 static void vesa_setwrpage(int page)
 {
 vesa_r.eax=0x4f05;
 vesa_r.ebx=vesa_write_window;
 vesa_r.edx=page*64/vesa_granularity;
-__svgalib_LRMI_int(0x10,&vesa_r);
+LRMI_int(0x10,&vesa_r);
 }
 
 
@@ -279,7 +279,7 @@ static void vesa_setdisplaystart(int add
   vesa_r.ecx=address % vesa_logical_width;
   vesa_r.edx=address / vesa_logical_width;
 
-  __svgalib_LRMI_int(0x10,&vesa_r);
+  LRMI_int(0x10,&vesa_r);
 
 }
 
@@ -290,7 +290,7 @@ static void vesa_setlogicalwidth(int wid
   vesa_r.eax=0x4f06;
   vesa_r.ebx=0;
   vesa_r.ecx=width / vesa_bpp ;
-  __svgalib_LRMI_int(0x10,&vesa_r);
+  LRMI_int(0x10,&vesa_r);
   vesa_logical_width=vesa_r.ebx;
 
 }
@@ -300,14 +300,14 @@ static int vesa_linear(int op, int param
 if (op==LINEAR_ENABLE) {  
   vesa_r.eax=0x4f02;
   vesa_r.ebx=vesa_last_mode_set|0x4000;
-  __svgalib_LRMI_int(0x10,&vesa_r);
+  LRMI_int(0x10,&vesa_r);
   vesa_is_linear=1;
 };
 
 if (op==LINEAR_DISABLE){ 
   vesa_r.eax=0x4f02;
   vesa_r.ebx=vesa_last_mode_set;
-  __svgalib_LRMI_int(0x10,&vesa_r);
+  LRMI_int(0x10,&vesa_r);
   vesa_is_linear=0;
 };
 if (op==LINEAR_QUERY_BASE) {return vesa_linear_base ;}
@@ -391,8 +391,8 @@ static int vesa_init(int force, int par1
     };
 
     if(!lrmi_inited) {
-        __svgalib_LRMI_init();
-        vesa_data.info = __svgalib_LRMI_alloc_real(sizeof(struct vbe_info_block)
+        LRMI_init();
+        vesa_data.info = LRMI_alloc_real(sizeof(struct vbe_info_block)
 	                 + sizeof(struct vbe_mode_info_block));
         vesa_data.mode = (struct vbe_mode_info_block *)(vesa_data.info + 1);
         lrmi_inited=1;
@@ -405,7 +405,7 @@ static int vesa_init(int force, int par1
     
     memcpy(vesa_data.info->vbe_signature, "VBE2", 4);
 
-    __svgalib_LRMI_int(0x10, &vesa_r);
+    LRMI_int(0x10, &vesa_r);
     
     if ((vesa_r.eax & 0xffff) != 0x4f || strncmp(vesa_data.info->vbe_signature, "VESA", 4) != 0) {
        	fprintf(stderr,"No VESA bios detected!\n");
@@ -435,7 +435,7 @@ static int vesa_init(int force, int par1
 
        if((vesa_chiptype>=1)&&(vesa_data.mode->mode_attributes&0x80))
           vesa_linear_base=vesa_data.mode->phys_base_ptr;
-       if (!__svgalib_LRMI_int(0x10, &vesa_r)) {
+       if (!LRMI_int(0x10, &vesa_r)) {
           fprintf(stderr, "Can't get mode info (vm86 failure)\n");
           return 1;
        }
@@ -559,7 +559,7 @@ static int vesa_init(int force, int par1
     vesa_r.edx=0;
     vesa_r.ecx=__svgalib_VESA_savebitmap;
     vesa_r.ebx=0;
-    __svgalib_LRMI_int(0x10,&vesa_r);
+    LRMI_int(0x10,&vesa_r);
     vesa_regs_size=vesa_r.ebx*64;
 
     SVGALIB_VESA[TEXT]=3;
@@ -580,7 +580,7 @@ static int vesa_init(int force, int par1
     cardspecs->matchProgrammableClock=vesa_match_programmable_clock;
     __svgalib_driverspecs = &__svgalib_vesa_driverspecs;
 
-    LRMI_mem1 = __svgalib_LRMI_alloc_real(vesa_regs_size);
+    LRMI_mem1 = LRMI_alloc_real(vesa_regs_size);
 
     __svgalib_banked_mem_base=0xa0000;
     __svgalib_banked_mem_size=0x10000;
