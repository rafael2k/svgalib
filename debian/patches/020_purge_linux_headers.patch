Author: Guillem Jover <guillem@debian.org>

Index: b/gl/inlstring.h
===================================================================
--- a/gl/inlstring.h
+++ b/gl/inlstring.h
@@ -1,6 +1,6 @@
 /* Based on functions in linux/string.h */
 
-#include <linux/types.h>	/* for size_t */
+#include <stddef.h>	/* for size_t */
 
 #if defined(__alpha__) || defined (NO_ASSEMBLY)
 
Index: b/src/et6000.c
===================================================================
--- a/src/et6000.c
+++ b/src/et6000.c
@@ -13,7 +13,6 @@
 #include "vga.h"
 #include "libvga.h"
 #include "driver.h"
-#include <linux/pci.h>
 #include "timing.h"
 #include "interface.h"
 #include "vgaregs.h"
Index: b/src/fbdev.c
===================================================================
--- a/src/fbdev.c
+++ b/src/fbdev.c
@@ -1,13 +1,13 @@
 #include <sys/types.h>
 #include <sys/ioctl.h>
 #include <sys/mman.h>
-#include <linux/fb.h>
-#include <linux/kd.h>
 #include <unistd.h>
 #include <fcntl.h>
 #include <stdio.h>
 #include <stdlib.h>
 
+#include "kd_lnx.h"
+#include "fb_lnx.h"
 #include "vga.h"
 #include "libvga.h"
 #include "driver.h"
@@ -353,7 +353,7 @@ static void fbdev_savepalette(unsigned c
 			unsigned char *green,
 			unsigned char *blue)
 {
-	__u16 r[256], g[256], b[256], t[256];
+	uint16_t r[256], g[256], b[256], t[256];
 	struct fb_cmap cmap;
 	unsigned i;
 
@@ -379,7 +379,7 @@ static void fbdev_restorepalette(const u
 			   const unsigned char *green,
 			   const unsigned char *blue)
 {
-	__u16 r[256], g[256], b[256], t[256];
+	uint16_t r[256], g[256], b[256], t[256];
 	struct fb_cmap cmap;
 	unsigned i;
 
@@ -403,7 +403,7 @@ static void fbdev_restorepalette(const u
 
 static int fbdev_setpalette(int index, int red, int green, int blue)
 {
-	__u16 r, g, b, t;
+	uint16_t r, g, b, t;
 	struct fb_cmap cmap;
 
 	r = (red << 10) | (red << 4) | (red >> 2);
@@ -424,7 +424,7 @@ static int fbdev_setpalette(int index, i
 
 static void fbdev_getpalette(int index, int *red, int *green, int *blue)
 {
-	__u16 r, g, b, t;
+	uint16_t r, g, b, t;
 	struct fb_cmap cmap;
 
 	cmap.start = 0;
Index: b/src/fb_lnx.h
===================================================================
--- /dev/null
+++ b/src/fb_lnx.h
@@ -0,0 +1,331 @@
+#ifndef _LINUX_FB_H
+#define _LINUX_FB_H
+
+#include <stdint.h>
+
+/* Definitions of frame buffers						*/
+
+#define FB_MAJOR		29
+#define FB_MAX			32	/* sufficient for now */
+
+/* ioctls
+   0x46 is 'F'								*/
+#define FBIOGET_VSCREENINFO	0x4600
+#define FBIOPUT_VSCREENINFO	0x4601
+#define FBIOGET_FSCREENINFO	0x4602
+#define FBIOGETCMAP		0x4604
+#define FBIOPUTCMAP		0x4605
+#define FBIOPAN_DISPLAY		0x4606
+#define FBIO_CURSOR            _IOWR('F', 0x08, struct fb_cursor)
+/* 0x4607-0x460B are defined below */
+/* #define FBIOGET_MONITORSPEC	0x460C */
+/* #define FBIOPUT_MONITORSPEC	0x460D */
+/* #define FBIOSWITCH_MONIBIT	0x460E */
+#define FBIOGET_CON2FBMAP	0x460F
+#define FBIOPUT_CON2FBMAP	0x4610
+#define FBIOBLANK		0x4611		/* arg: 0 or vesa level + 1 */
+#define FBIOGET_VBLANK		_IOR('F', 0x12, struct fb_vblank)
+#define FBIO_ALLOC              0x4613
+#define FBIO_FREE               0x4614
+#define FBIOGET_GLYPH           0x4615
+#define FBIOGET_HWCINFO         0x4616
+#define FBIOPUT_MODEINFO        0x4617
+#define FBIOGET_DISPINFO        0x4618
+
+
+#define FB_TYPE_PACKED_PIXELS		0	/* Packed Pixels	*/
+#define FB_TYPE_PLANES			1	/* Non interleaved planes */
+#define FB_TYPE_INTERLEAVED_PLANES	2	/* Interleaved planes	*/
+#define FB_TYPE_TEXT			3	/* Text/attributes	*/
+#define FB_TYPE_VGA_PLANES		4	/* EGA/VGA planes	*/
+
+#define FB_AUX_TEXT_MDA		0	/* Monochrome text */
+#define FB_AUX_TEXT_CGA		1	/* CGA/EGA/VGA Color text */
+#define FB_AUX_TEXT_S3_MMIO	2	/* S3 MMIO fasttext */
+#define FB_AUX_TEXT_MGA_STEP16	3	/* MGA Millenium I: text, attr, 14 reserved bytes */
+#define FB_AUX_TEXT_MGA_STEP8	4	/* other MGAs:      text, attr,  6 reserved bytes */
+
+#define FB_AUX_VGA_PLANES_VGA4		0	/* 16 color planes (EGA/VGA) */
+#define FB_AUX_VGA_PLANES_CFB4		1	/* CFB4 in planes (VGA) */
+#define FB_AUX_VGA_PLANES_CFB8		2	/* CFB8 in planes (VGA) */
+
+#define FB_VISUAL_MONO01		0	/* Monochr. 1=Black 0=White */
+#define FB_VISUAL_MONO10		1	/* Monochr. 1=White 0=Black */
+#define FB_VISUAL_TRUECOLOR		2	/* True color	*/
+#define FB_VISUAL_PSEUDOCOLOR		3	/* Pseudo color (like atari) */
+#define FB_VISUAL_DIRECTCOLOR		4	/* Direct color */
+#define FB_VISUAL_STATIC_PSEUDOCOLOR	5	/* Pseudo color readonly */
+
+#define FB_ACCEL_NONE		0	/* no hardware accelerator	*/
+#define FB_ACCEL_ATARIBLITT	1	/* Atari Blitter		*/
+#define FB_ACCEL_AMIGABLITT	2	/* Amiga Blitter                */
+#define FB_ACCEL_S3_TRIO64	3	/* Cybervision64 (S3 Trio64)    */
+#define FB_ACCEL_NCR_77C32BLT	4	/* RetinaZ3 (NCR 77C32BLT)      */
+#define FB_ACCEL_S3_VIRGE	5	/* Cybervision64/3D (S3 ViRGE)	*/
+#define FB_ACCEL_ATI_MACH64GX	6	/* ATI Mach 64GX family		*/
+#define FB_ACCEL_DEC_TGA	7	/* DEC 21030 TGA		*/
+#define FB_ACCEL_ATI_MACH64CT	8	/* ATI Mach 64CT family		*/
+#define FB_ACCEL_ATI_MACH64VT	9	/* ATI Mach 64CT family VT class */
+#define FB_ACCEL_ATI_MACH64GT	10	/* ATI Mach 64CT family GT class */
+#define FB_ACCEL_SUN_CREATOR	11	/* Sun Creator/Creator3D	*/
+#define FB_ACCEL_SUN_CGSIX	12	/* Sun cg6			*/
+#define FB_ACCEL_SUN_LEO	13	/* Sun leo/zx			*/
+#define FB_ACCEL_IMS_TWINTURBO	14	/* IMS Twin Turbo		*/
+#define FB_ACCEL_3DLABS_PERMEDIA2 15	/* 3Dlabs Permedia 2		*/
+#define FB_ACCEL_MATROX_MGA2064W 16	/* Matrox MGA2064W (Millenium)	*/
+#define FB_ACCEL_MATROX_MGA1064SG 17	/* Matrox MGA1064SG (Mystique)	*/
+#define FB_ACCEL_MATROX_MGA2164W 18	/* Matrox MGA2164W (Millenium II) */
+#define FB_ACCEL_MATROX_MGA2164W_AGP 19	/* Matrox MGA2164W (Millenium II) */
+#define FB_ACCEL_MATROX_MGAG100	20	/* Matrox G100 (Productiva G100) */
+#define FB_ACCEL_MATROX_MGAG200	21	/* Matrox G200 (Myst, Mill, ...) */
+#define FB_ACCEL_SUN_CG14	22	/* Sun cgfourteen		 */
+#define FB_ACCEL_SUN_BWTWO	23	/* Sun bwtwo			*/
+#define FB_ACCEL_SUN_CGTHREE	24	/* Sun cgthree			*/
+#define FB_ACCEL_SUN_TCX	25	/* Sun tcx			*/
+#define FB_ACCEL_MATROX_MGAG400	26	/* Matrox G400			*/
+#define FB_ACCEL_NV3		27	/* nVidia RIVA 128              */
+#define FB_ACCEL_NV4		28	/* nVidia RIVA TNT		*/
+#define FB_ACCEL_NV5		29	/* nVidia RIVA TNT2		*/
+#define FB_ACCEL_CT_6555x	30	/* C&T 6555x			*/
+#define FB_ACCEL_3DFX_BANSHEE	31	/* 3Dfx Banshee			*/
+#define FB_ACCEL_ATI_RAGE128	32	/* ATI Rage128 family		*/
+#define FB_ACCEL_IGS_CYBER2000	33	/* CyberPro 2000		*/
+#define FB_ACCEL_IGS_CYBER2010	34	/* CyberPro 2010		*/
+#define FB_ACCEL_IGS_CYBER5000	35	/* CyberPro 5000		*/
+#define FB_ACCEL_SIS_GLAMOUR    36	/* SiS 300/630/540              */
+#define FB_ACCEL_3DLABS_PERMEDIA3 37	/* 3Dlabs Permedia 3		*/
+#define FB_ACCEL_ATI_RADEON	38	/* ATI Radeon family		*/
+#define FB_ACCEL_I810           39      /* Intel 810/815                */
+#define FB_ACCEL_SIS_GLAMOUR_2  40	/* SiS 315, 650, 740		*/
+#define FB_ACCEL_SIS_XABRE      41	/* SiS 330 ("Xabre")		*/
+
+#define FB_ACCEL_NEOMAGIC_NM2070 90	/* NeoMagic NM2070              */
+#define FB_ACCEL_NEOMAGIC_NM2090 91	/* NeoMagic NM2090              */
+#define FB_ACCEL_NEOMAGIC_NM2093 92	/* NeoMagic NM2093              */
+#define FB_ACCEL_NEOMAGIC_NM2097 93	/* NeoMagic NM2097              */
+#define FB_ACCEL_NEOMAGIC_NM2160 94	/* NeoMagic NM2160              */
+#define FB_ACCEL_NEOMAGIC_NM2200 95	/* NeoMagic NM2200              */
+#define FB_ACCEL_NEOMAGIC_NM2230 96	/* NeoMagic NM2230              */
+#define FB_ACCEL_NEOMAGIC_NM2360 97	/* NeoMagic NM2360              */
+#define FB_ACCEL_NEOMAGIC_NM2380 98	/* NeoMagic NM2380              */
+
+
+struct fb_fix_screeninfo {
+	char id[16];			/* identification string eg "TT Builtin" */
+	unsigned long smem_start;	/* Start of frame buffer mem */
+					/* (physical address) */
+	uint32_t smem_len;			/* Length of frame buffer mem */
+	uint32_t type;			/* see FB_TYPE_*		*/
+	uint32_t type_aux;			/* Interleave for interleaved Planes */
+	uint32_t visual;			/* see FB_VISUAL_*		*/ 
+	uint16_t xpanstep;			/* zero if no hardware panning  */
+	uint16_t ypanstep;			/* zero if no hardware panning  */
+	uint16_t ywrapstep;		/* zero if no hardware ywrap    */
+	uint32_t line_length;		/* length of a line in bytes    */
+	unsigned long mmio_start;	/* Start of Memory Mapped I/O   */
+					/* (physical address) */
+	uint32_t mmio_len;			/* Length of Memory Mapped I/O  */
+	uint32_t accel;			/* Type of acceleration available */
+	uint16_t reserved[3];		/* Reserved for future compatibility */
+};
+
+/* Interpretation of offset for color fields: All offsets are from the right,
+ * inside a "pixel" value, which is exactly 'bits_per_pixel' wide (means: you
+ * can use the offset as right argument to <<). A pixel afterwards is a bit
+ * stream and is written to video memory as that unmodified. This implies
+ * big-endian byte order if bits_per_pixel is greater than 8.
+ */
+struct fb_bitfield {
+	uint32_t offset;			/* beginning of bitfield	*/
+	uint32_t length;			/* length of bitfield		*/
+	uint32_t msb_right;		/* != 0 : Most significant bit is */ 
+					/* right */ 
+};
+
+#define FB_NONSTD_HAM		1	/* Hold-And-Modify (HAM)        */
+
+#define FB_ACTIVATE_NOW		0	/* set values immediately (or vbl)*/
+#define FB_ACTIVATE_NXTOPEN	1	/* activate on next open	*/
+#define FB_ACTIVATE_TEST	2	/* don't set, round up impossible */
+#define FB_ACTIVATE_MASK       15
+					/* values			*/
+#define FB_ACTIVATE_VBL	       16	/* activate values on next vbl  */
+#define FB_CHANGE_CMAP_VBL     32	/* change colormap on vbl	*/
+#define FB_ACTIVATE_ALL	       64	/* change all VCs on this fb	*/
+
+#define FB_ACCELF_TEXT		1	/* text mode acceleration */
+
+#define FB_SYNC_HOR_HIGH_ACT	1	/* horizontal sync high active	*/
+#define FB_SYNC_VERT_HIGH_ACT	2	/* vertical sync high active	*/
+#define FB_SYNC_EXT		4	/* external sync		*/
+#define FB_SYNC_COMP_HIGH_ACT	8	/* composite sync high active   */
+#define FB_SYNC_BROADCAST	16	/* broadcast video timings      */
+					/* vtotal = 144d/288n/576i => PAL  */
+					/* vtotal = 121d/242n/484i => NTSC */
+#define FB_SYNC_ON_GREEN	32	/* sync on green */
+
+#define FB_VMODE_NONINTERLACED  0	/* non interlaced */
+#define FB_VMODE_INTERLACED	1	/* interlaced	*/
+#define FB_VMODE_DOUBLE		2	/* double scan */
+#define FB_VMODE_MASK		255
+
+#define FB_VMODE_YWRAP		256	/* ywrap instead of panning     */
+#define FB_VMODE_SMOOTH_XPAN	512	/* smooth xpan possible (internally used) */
+#define FB_VMODE_CONUPDATE	512	/* don't update x/yoffset	*/
+
+#define PICOS2KHZ(a) (1000000000UL/(a))
+#define KHZ2PICOS(a) (1000000000UL/(a))
+
+struct fb_var_screeninfo {
+	uint32_t xres;			/* visible resolution		*/
+	uint32_t yres;
+	uint32_t xres_virtual;		/* virtual resolution		*/
+	uint32_t yres_virtual;
+	uint32_t xoffset;			/* offset from virtual to visible */
+	uint32_t yoffset;			/* resolution			*/
+
+	uint32_t bits_per_pixel;		/* guess what			*/
+	uint32_t grayscale;		/* != 0 Graylevels instead of colors */
+
+	struct fb_bitfield red;		/* bitfield in fb mem if true color, */
+	struct fb_bitfield green;	/* else only length is significant */
+	struct fb_bitfield blue;
+	struct fb_bitfield transp;	/* transparency			*/	
+
+	uint32_t nonstd;			/* != 0 Non standard pixel format */
+
+	uint32_t activate;			/* see FB_ACTIVATE_*		*/
+
+	uint32_t height;			/* height of picture in mm    */
+	uint32_t width;			/* width of picture in mm     */
+
+	uint32_t accel_flags;		/* acceleration flags (hints)	*/
+
+	/* Timing: All values in pixclocks, except pixclock (of course) */
+	uint32_t pixclock;			/* pixel clock in ps (pico seconds) */
+	uint32_t left_margin;		/* time from sync to picture	*/
+	uint32_t right_margin;		/* time from picture to sync	*/
+	uint32_t upper_margin;		/* time from sync to picture	*/
+	uint32_t lower_margin;
+	uint32_t hsync_len;		/* length of horizontal sync	*/
+	uint32_t vsync_len;		/* length of vertical sync	*/
+	uint32_t sync;			/* see FB_SYNC_*		*/
+	uint32_t vmode;			/* see FB_VMODE_*		*/
+	uint32_t rotate;			/* angle we rotate counter clockwise */
+	uint32_t reserved[5];		/* Reserved for future compatibility */
+};
+
+struct fb_cmap {
+	uint32_t start;			/* First entry	*/
+	uint32_t len;			/* Number of entries */
+	uint16_t *red;			/* Red values	*/
+	uint16_t *green;
+	uint16_t *blue;
+	uint16_t *transp;			/* transparency, can be NULL */
+};
+
+struct fb_con2fbmap {
+	uint32_t console;
+	uint32_t framebuffer;
+};
+
+/* VESA Blanking Levels */
+#define VESA_NO_BLANKING        0
+#define VESA_VSYNC_SUSPEND      1
+#define VESA_HSYNC_SUSPEND      2
+#define VESA_POWERDOWN          3
+
+struct fb_monspecs {
+	uint32_t hfmin;			/* hfreq lower limit (Hz) */
+	uint32_t hfmax; 			/* hfreq upper limit (Hz) */
+	uint16_t vfmin;			/* vfreq lower limit (Hz) */
+	uint16_t vfmax;			/* vfreq upper limit (Hz) */
+	uint32_t dclkmin;                  /* pixelclock lower limit (Hz) */
+	uint32_t dclkmax;                  /* pixelclock upper limit (Hz) */
+	unsigned gtf  : 1;              /* supports GTF */
+	unsigned dpms : 1;		/* supports DPMS */
+};
+
+#define FB_VBLANK_VBLANKING	0x001	/* currently in a vertical blank */
+#define FB_VBLANK_HBLANKING	0x002	/* currently in a horizontal blank */
+#define FB_VBLANK_HAVE_VBLANK	0x004	/* vertical blanks can be detected */
+#define FB_VBLANK_HAVE_HBLANK	0x008	/* horizontal blanks can be detected */
+#define FB_VBLANK_HAVE_COUNT	0x010	/* global retrace counter is available */
+#define FB_VBLANK_HAVE_VCOUNT	0x020	/* the vcount field is valid */
+#define FB_VBLANK_HAVE_HCOUNT	0x040	/* the hcount field is valid */
+#define FB_VBLANK_VSYNCING	0x080	/* currently in a vsync */
+#define FB_VBLANK_HAVE_VSYNC	0x100	/* verical syncs can be detected */
+
+struct fb_vblank {
+	uint32_t flags;			/* FB_VBLANK flags */
+	uint32_t count;			/* counter of retraces since boot */
+	uint32_t vcount;			/* current scanline position */
+	uint32_t hcount;			/* current scandot position */
+	uint32_t reserved[4];		/* reserved for future compatibility */
+};
+
+/* Internal HW accel */
+#define ROP_COPY 0
+/* #define ROP_XOR  1		Already defined by svgalib */
+
+struct fb_copyarea {
+	uint32_t dx;
+	uint32_t dy;
+	uint32_t width;
+	uint32_t height;
+	uint32_t sx;
+	uint32_t sy;
+};
+
+struct fb_fillrect {
+	uint32_t dx;	/* screen-relative */
+	uint32_t dy;
+	uint32_t width;
+	uint32_t height;
+	uint32_t color;
+	uint32_t rop;
+};
+
+struct fb_image {
+	uint32_t dx;		/* Where to place image */
+	uint32_t dy;
+	uint32_t width;		/* Size of image */
+	uint32_t height;
+	uint32_t fg_color;		/* Only used when a mono bitmap */
+	uint32_t bg_color;
+	uint8_t  depth;		/* Depth of the image */
+	const char *data;	/* Pointer to image data */
+	struct fb_cmap cmap;	/* color map info */
+};
+
+/*
+ * hardware cursor control
+ */
+
+#define FB_CUR_SETCUR   0x01
+#define FB_CUR_SETPOS   0x02
+#define FB_CUR_SETHOT   0x04
+#define FB_CUR_SETCMAP  0x08
+#define FB_CUR_SETSHAPE 0x10
+#define FB_CUR_SETSIZE	0x20
+#define FB_CUR_SETALL   0xFF
+
+struct fbcurpos {
+	uint16_t x, y;
+};
+
+struct fb_cursor {
+	uint16_t set;		/* what to set */
+	uint16_t enable;		/* cursor on/off */
+	uint16_t rop;		/* bitop operation */
+	char *mask;		/* cursor mask bits */
+	struct fbcurpos hot;	/* cursor hot spot */
+	struct fb_image	image;	/* Cursor image */
+};
+
+#define FB_PIXMAP_DEFAULT 1     /* used internally by fbcon */
+#define FB_PIXMAP_SYSTEM  2     /* memory is in system RAM  */
+#define FB_PIXMAP_IO      4     /* memory is iomapped       */
+#define FB_PIXMAP_SYNC    256   /* set if GPU can DMA       */
+
+#endif /* _LINUX_FB_H */
Index: b/src/joystick/joydev.h
===================================================================
--- a/src/joystick/joydev.h
+++ b/src/joystick/joydev.h
@@ -1,46 +1,45 @@
-#include <linux/version.h>
+#ifndef _LINUX_JOYSTICK_H
+#define _LINUX_JOYSTICK_H
 
-#if ( LINUX_VESION_CODE >= 131584) 
-#include <linux/joystick.h>
-#else
-/* Joystick interface modeled after svgalibs keyboard and mouse interfaces 
- * Copyright 1998 Daniel Engström <daniel.engstrom@riksnett.no> 
- * Partly based on code from 
- * joystick-0.7.3 Copyright (C) 1992, 1993 Author C. Smith
- * and 
- * joystick-1.0.6 Copyright (C) 1997 Vojtech Pavlik 
+/*
+ * $Id: joystick.h,v 1.3 2000/11/30 11:07:05 vojtech Exp $
+ *
+ *  Copyright (C) 1996-2000 Vojtech Pavlik
+ *
+ *  Sponsored by SuSE
  */
 
-#include <sys/ioctl.h> /* for _IOR(x) and _IOW(x) macros */ 
-#include <sys/types.h>
 /*
- * IOCTL commands for joystick driver
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or 
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * 
+ * Should you need to contact me, the author, you can do so either by
+ * e-mail - mail your message to <vojtech@suse.cz>, or by paper mail:
+ * Vojtech Pavlik, Ucitelska 1576, Prague 8, 182 00 Czech Republic
  */
-				/* get driver version */
-#define JSIOCGVERSION		_IOR('j', 0x01, u_int32_t)
 
-				/* get number of axes */
-#define JSIOCGAXES		_IOR('j', 0x11, u_int8_t)
-				/* get number of buttons */
-#define JSIOCGBUTTONS		_IOR('j', 0x12, u_int8_t)
-
-		                /* set correction values */
-#define JSIOCSCORR		_IOW('j', 0x21, struct js_corr[4])
-		                /* get correction values */
-#define JSIOCGCORR		_IOR('j', 0x22, struct js_corr[4])
+#include <stdint.h>
+#include <sys/ioctl.h> /* for _IOR(x) and _IOW(x) macros */
+
+/* From <linux/input.h> */
+#define KEY_MAX                 0x1ff
 
 /*
- * Types and constants for get/set correction
+ * Version
  */
 
-#define JS_CORR_NONE		0x00		/* returns raw values */
-#define JS_CORR_BROKEN		0x01		/* broken line */
-
-struct js_corr {
-	int32_t coef[8];
-	u_int16_t prec;
-	u_int16_t type;
-};
+#define JS_VERSION		0x020100
 
 /*
  * Types and constants for reading from /dev/js
@@ -51,41 +50,82 @@ struct js_corr {
 #define JS_EVENT_INIT		0x80	/* initial state of device */
 
 struct js_event {
-        u_int32_t time;		/* time when event happened in miliseconds 
-				 * since open */
-        u_int16_t value;	/* new value */
-        u_int8_t  type;		/* type of event, see above */
-        u_int8_t  number;	/* axis/button number */
+	uint32_t time;	/* event timestamp in milliseconds */
+	int16_t value;	/* value */
+	uint8_t type;	/* event type */
+	uint8_t number;	/* axis/button number */
+};
+
+/*
+ * IOCTL commands for joystick driver
+ */
+
+#define JSIOCGVERSION		_IOR('j', 0x01, uint32_t)				/* get driver version */
+
+#define JSIOCGAXES		_IOR('j', 0x11, uint8_t)				/* get number of axes */
+#define JSIOCGBUTTONS		_IOR('j', 0x12, uint8_t)				/* get number of buttons */
+#define JSIOCGNAME(len)		_IOC(_IOC_READ, 'j', 0x13, len)			/* get identifier string */
+
+#define JSIOCSCORR		_IOW('j', 0x21, struct js_corr)			/* set correction values */
+#define JSIOCGCORR		_IOR('j', 0x22, struct js_corr)			/* get correction values */
+
+#define JSIOCSAXMAP		_IOW('j', 0x31, uint8_t[ABS_MAX])			/* set axis mapping */
+#define JSIOCGAXMAP		_IOR('j', 0x32, uint8_t[ABS_MAX])			/* get axis mapping */
+#define JSIOCSBTNMAP		_IOW('j', 0x33, uint16_t[KEY_MAX - BTN_MISC])	/* set button mapping */
+#define JSIOCGBTNMAP		_IOR('j', 0x34, uint16_t[KEY_MAX - BTN_MISC])	/* get button mapping */
+
+/*
+ * Types and constants for get/set correction
+ */
+
+#define JS_CORR_NONE		0x00	/* returns raw values */
+#define JS_CORR_BROKEN		0x01	/* broken line */
+
+struct js_corr {
+	int32_t coef[8];
+	int16_t prec;
+	uint16_t type;
 };
 
 /*
- * Backward (version 0.x) compatibility definitions
+ * v0.x compatibility definitions
  */
 
-#define JS_RETURN 	sizeof(struct JS_DATA_TYPE)
-#define JS_TRUE 	1
-#define JS_FALSE 	0
-#define JS_X_0		0x01		/* bit mask for x-axis js0 */
-#define JS_Y_0		0x02		/* bit mask for y-axis js0 */
-#define JS_X_1		0x04		/* bit mask for x-axis js1 */
-#define JS_Y_1		0x08		/* bit mask for y-axis js1 */
-#define JS_MAX 		2		/* max number of joysticks */
-
-#define JS_SET_CAL 0x01		/*ioctl cmd to set joystick correction factor*/
-#define JS_GET_CAL 0x02		/*ioctl cmd to get joystick correction factor*/
-#define JS_SET_TIMEOUT 0x03	/*ioctl cmd to set maximum number of iterations
-				  to wait for a timeout*/
-#define JS_GET_TIMEOUT		0x04	/*as above, to get*/
-#define JS_SET_TIMELIMIT	0x05	/*set data retention time*/
-#define JS_GET_TIMELIMIT	0x06	/*get data retention time*/
-#define JS_GET_ALL		0x07	/*get the whole JS_DATA[minor] struct*/
-#define JS_SET_ALL		0x08	/*set the whole JS_DATA[minor] struct
-						  except JS_BUSY!*/
+#define JS_RETURN		sizeof(struct JS_DATA_TYPE)
+#define JS_TRUE			1
+#define JS_FALSE		0
+#define JS_X_0			0x01
+#define JS_Y_0			0x02
+#define JS_X_1			0x04
+#define JS_Y_1			0x08
+#define JS_MAX			2
+
+#define JS_DEF_TIMEOUT		0x1300
+#define JS_DEF_CORR		0
+#define JS_DEF_TIMELIMIT	10L
+
+#define JS_SET_CAL		1
+#define JS_GET_CAL		2
+#define JS_SET_TIMEOUT		3
+#define JS_GET_TIMEOUT		4
+#define JS_SET_TIMELIMIT	5
+#define JS_GET_TIMELIMIT	6
+#define JS_GET_ALL		7
+#define JS_SET_ALL		8
 
-/* version 0.x struct */
 struct JS_DATA_TYPE {
-	int buttons;		/* immediate button state */
-	int x;                  /* immediate x axis value */
-	int y;                  /* immediate y axis value */
+	int buttons;
+	int x;
+	int y;
 };
-#endif
+
+struct JS_DATA_SAVE_TYPE {
+	int JS_TIMEOUT;
+	int BUSY;
+	long JS_EXPIRETIME;
+	long JS_TIMELIMIT;
+	struct JS_DATA_TYPE JS_SAVE;
+	struct JS_DATA_TYPE JS_CORR;
+};
+
+#endif /* _LINUX_JOYSTICK_H */
Index: b/src/kd_lnx.h
===================================================================
--- /dev/null
+++ b/src/kd_lnx.h
@@ -0,0 +1,167 @@
+#ifndef _LINUX_KD_H
+#define _LINUX_KD_H
+
+/* 0x4B is 'K', to avoid collision with termios and vt */
+
+#define GIO_FONT	0x4B60	/* gets font in expanded form */
+#define PIO_FONT	0x4B61	/* use font in expanded form */
+
+#define GIO_FONTX	0x4B6B	/* get font using struct consolefontdesc */
+#define PIO_FONTX	0x4B6C	/* set font using struct consolefontdesc */
+struct consolefontdesc {
+	unsigned short charcount;	/* characters in font (256 or 512) */
+	unsigned short charheight;	/* scan lines per character (1-32) */
+	char *chardata;			/* font data in expanded form */
+};
+
+#define PIO_FONTRESET   0x4B6D	/* reset to default font */
+
+#define GIO_CMAP	0x4B70	/* gets colour palette on VGA+ */
+#define PIO_CMAP	0x4B71	/* sets colour palette on VGA+ */
+
+#define KIOCSOUND	0x4B2F	/* start sound generation (0 for off) */
+#define KDMKTONE	0x4B30	/* generate tone */
+
+#define KDGETLED	0x4B31	/* return current led state */
+#define KDSETLED	0x4B32	/* set led state [lights, not flags] */
+#define 	LED_SCR		0x01	/* scroll lock led */
+#define 	LED_NUM		0x02	/* num lock led */
+#define 	LED_CAP		0x04	/* caps lock led */
+
+#define KDGKBTYPE	0x4B33	/* get keyboard type */
+#define 	KB_84		0x01
+#define 	KB_101		0x02 	/* this is what we always answer */
+#define 	KB_OTHER	0x03
+
+#define KDADDIO		0x4B34	/* add i/o port as valid */
+#define KDDELIO		0x4B35	/* del i/o port as valid */
+#define KDENABIO	0x4B36	/* enable i/o to video board */
+#define KDDISABIO	0x4B37	/* disable i/o to video board */
+
+#define KDSETMODE	0x4B3A	/* set text/graphics mode */
+#define		KD_TEXT		0x00
+#define		KD_GRAPHICS	0x01
+#define		KD_TEXT0	0x02	/* obsolete */
+#define		KD_TEXT1	0x03	/* obsolete */
+#define KDGETMODE	0x4B3B	/* get current mode */
+
+#define KDMAPDISP	0x4B3C	/* map display into address space */
+#define KDUNMAPDISP	0x4B3D	/* unmap display from address space */
+
+typedef char scrnmap_t;
+#define		E_TABSZ		256
+#define GIO_SCRNMAP	0x4B40	/* get screen mapping from kernel */
+#define PIO_SCRNMAP	0x4B41	/* put screen mapping table in kernel */
+#define GIO_UNISCRNMAP  0x4B69	/* get full Unicode screen mapping */
+#define PIO_UNISCRNMAP  0x4B6A  /* set full Unicode screen mapping */
+
+#define GIO_UNIMAP	0x4B66	/* get unicode-to-font mapping from kernel */
+struct unipair {
+	unsigned short unicode;
+	unsigned short fontpos;
+};
+struct unimapdesc {
+	unsigned short entry_ct;
+	struct unipair *entries;
+};
+#define PIO_UNIMAP	0x4B67	/* put unicode-to-font mapping in kernel */
+#define PIO_UNIMAPCLR	0x4B68	/* clear table, possibly advise hash algorithm */
+struct unimapinit {
+	unsigned short advised_hashsize;  /* 0 if no opinion */
+	unsigned short advised_hashstep;  /* 0 if no opinion */
+	unsigned short advised_hashlevel; /* 0 if no opinion */
+};
+
+#define UNI_DIRECT_BASE 0xF000	/* start of Direct Font Region */
+#define UNI_DIRECT_MASK 0x01FF	/* Direct Font Region bitmask */
+
+#define		K_RAW		0x00
+#define		K_XLATE		0x01
+#define		K_MEDIUMRAW	0x02
+#define		K_UNICODE	0x03
+#define KDGKBMODE	0x4B44	/* gets current keyboard mode */
+#define KDSKBMODE	0x4B45	/* sets current keyboard mode */
+
+#define		K_METABIT	0x03
+#define		K_ESCPREFIX	0x04
+#define KDGKBMETA	0x4B62	/* gets meta key handling mode */
+#define KDSKBMETA	0x4B63	/* sets meta key handling mode */
+
+#define		K_SCROLLLOCK	0x01
+#define		K_NUMLOCK	0x02
+#define		K_CAPSLOCK	0x04
+#define	KDGKBLED	0x4B64	/* get led flags (not lights) */
+#define	KDSKBLED	0x4B65	/* set led flags (not lights) */
+
+struct kbentry {
+	unsigned char kb_table;
+	unsigned char kb_index;
+	unsigned short kb_value;
+};
+#define		K_NORMTAB	0x00
+#define		K_SHIFTTAB	0x01
+#define		K_ALTTAB	0x02
+#define		K_ALTSHIFTTAB	0x03
+
+#define KDGKBENT	0x4B46	/* gets one entry in translation table */
+#define KDSKBENT	0x4B47	/* sets one entry in translation table */
+
+struct kbsentry {
+	unsigned char kb_func;
+	unsigned char kb_string[512];
+};
+#define KDGKBSENT	0x4B48	/* gets one function key string entry */
+#define KDSKBSENT	0x4B49	/* sets one function key string entry */
+
+struct kbdiacr {
+        unsigned char diacr, base, result;
+};
+struct kbdiacrs {
+        unsigned int kb_cnt;    /* number of entries in following array */
+	struct kbdiacr kbdiacr[256];    /* MAX_DIACR from keyboard.h */
+};
+#define KDGKBDIACR      0x4B4A  /* read kernel accent table */
+#define KDSKBDIACR      0x4B4B  /* write kernel accent table */
+
+struct kbkeycode {
+	unsigned int scancode, keycode;
+};
+#define KDGETKEYCODE	0x4B4C	/* read kernel keycode table entry */
+#define KDSETKEYCODE	0x4B4D	/* write kernel keycode table entry */
+
+#define KDSIGACCEPT	0x4B4E	/* accept kbd generated signals */
+
+struct kbd_repeat {
+	int delay;	/* in msec; <= 0: don't change */
+	int period;	/* in msec; <= 0: don't change */
+			/* earlier this field was misnamed "rate" */
+};
+
+#define KDKBDREP        0x4B52  /* set keyboard delay/repeat rate;
+				 * actually used values are returned */
+
+#define KDFONTOP	0x4B72	/* font operations */
+
+struct console_font_op {
+	unsigned int op;	/* operation code KD_FONT_OP_* */
+	unsigned int flags;	/* KD_FONT_FLAG_* */
+	unsigned int width, height;	/* font size */
+	unsigned int charcount;
+	unsigned char *data;	/* font data with height fixed to 32 */
+};
+
+#define KD_FONT_OP_SET		0	/* Set font */
+#define KD_FONT_OP_GET		1	/* Get font */
+#define KD_FONT_OP_SET_DEFAULT	2	/* Set font to default, data points to name / NULL */
+#define KD_FONT_OP_COPY		3	/* Copy from another console */
+
+#define KD_FONT_FLAG_DONT_RECALC 	1	/* Don't recalculate hw charcell size [compat] */
+#ifdef __KERNEL__
+#define KD_FONT_FLAG_OLD		0x80000000	/* Invoked via old interface [compat] */
+#endif
+
+/* note: 0x4B00-0x4B4E all have had a value at some time;
+   don't reuse for the time being */
+/* note: 0x4B60-0x4B6D, 0x4B70-0x4B72 used above */
+
+#endif /* _LINUX_KD_H */
Index: b/src/keyboard/keyboard.c
===================================================================
--- a/src/keyboard/keyboard.c
+++ b/src/keyboard/keyboard.c
@@ -28,18 +28,18 @@
 #include <sys/ioctl.h>
 #include <fcntl.h>
 #include <termios.h>
-#include <linux/kd.h>
+#include "kd_lnx.h"
 /* linux/keyboard.h defines NR_KEYS and some scancode-like constants, so it */
 /* should also be useful for svgalib programs using the keyboard. It misses */
 /* a few KERNEL ifdefs around kernel data structures though. */
-#include <linux/keyboard.h>
+#include "keyboard_lnx.h"
 #include <sys/vt.h>
 /* Needed to check uid of keymap files */
 #include <sys/stat.h>
 #include <unistd.h>
 
 #include <vga.h>
-#include "../libvga.h"
+#include "libvga.h"
 #include "vgakeyboard.h"
 #include "driver.h"
 
Index: b/src/keyboard/keyboard_lnx.h
===================================================================
--- /dev/null
+++ b/src/keyboard/keyboard_lnx.h
@@ -0,0 +1,425 @@
+#ifndef __LINUX_KEYBOARD_H
+#define __LINUX_KEYBOARD_H
+
+/* From <linux/input.h> */
+#define KEY_MAX                 0x1ff
+
+#define KG_SHIFT	0
+#define KG_CTRL		2
+#define KG_ALT		3
+#define KG_ALTGR	1
+#define KG_SHIFTL	4
+#define KG_KANASHIFT	4
+#define KG_SHIFTR	5
+#define KG_CTRLL	6
+#define KG_CTRLR	7
+#define KG_CAPSSHIFT	8
+
+#define NR_SHIFT	9
+
+#define NR_KEYS		(KEY_MAX+1)
+#define MAX_NR_KEYMAPS	256
+/* This means 128Kb if all keymaps are allocated. Only the superuser
+	may increase the number of keymaps beyond MAX_NR_OF_USER_KEYMAPS. */
+#define MAX_NR_OF_USER_KEYMAPS 256 	/* should be at least 7 */
+
+#define MAX_NR_FUNC	256	/* max nr of strings assigned to keys */
+
+#define KT_LATIN	0	/* we depend on this being zero */
+#define KT_LETTER	11	/* symbol that can be acted upon by CapsLock */
+#define KT_FN		1
+#define KT_SPEC		2
+#define KT_PAD		3
+#define KT_DEAD		4
+#define KT_CONS		5
+#define KT_CUR		6
+#define KT_SHIFT	7
+#define KT_META		8
+#define KT_ASCII	9
+#define KT_LOCK		10
+#define KT_SLOCK	12
+
+#define K(t,v)		(((t)<<8)|(v))
+#define KTYP(x)		((x) >> 8)
+#define KVAL(x)		((x) & 0xff)
+
+#define K_F1		K(KT_FN,0)
+#define K_F2		K(KT_FN,1)
+#define K_F3		K(KT_FN,2)
+#define K_F4		K(KT_FN,3)
+#define K_F5		K(KT_FN,4)
+#define K_F6		K(KT_FN,5)
+#define K_F7		K(KT_FN,6)
+#define K_F8		K(KT_FN,7)
+#define K_F9		K(KT_FN,8)
+#define K_F10		K(KT_FN,9)
+#define K_F11		K(KT_FN,10)
+#define K_F12		K(KT_FN,11)
+#define K_F13		K(KT_FN,12)
+#define K_F14		K(KT_FN,13)
+#define K_F15		K(KT_FN,14)
+#define K_F16		K(KT_FN,15)
+#define K_F17		K(KT_FN,16)
+#define K_F18		K(KT_FN,17)
+#define K_F19		K(KT_FN,18)
+#define K_F20		K(KT_FN,19)
+#define K_FIND		K(KT_FN,20)
+#define K_INSERT	K(KT_FN,21)
+#define K_REMOVE	K(KT_FN,22)
+#define K_SELECT	K(KT_FN,23)
+#define K_PGUP		K(KT_FN,24) /* PGUP is a synonym for PRIOR */
+#define K_PGDN		K(KT_FN,25) /* PGDN is a synonym for NEXT */
+#define K_MACRO	 	K(KT_FN,26)
+#define K_HELP		K(KT_FN,27)
+#define K_DO		K(KT_FN,28)
+#define K_PAUSE	 	K(KT_FN,29)
+#define K_F21		K(KT_FN,30)
+#define K_F22		K(KT_FN,31)
+#define K_F23		K(KT_FN,32)
+#define K_F24		K(KT_FN,33)
+#define K_F25		K(KT_FN,34)
+#define K_F26		K(KT_FN,35)
+#define K_F27		K(KT_FN,36)
+#define K_F28		K(KT_FN,37)
+#define K_F29		K(KT_FN,38)
+#define K_F30		K(KT_FN,39)
+#define K_F31		K(KT_FN,40)
+#define K_F32		K(KT_FN,41)
+#define K_F33		K(KT_FN,42)
+#define K_F34		K(KT_FN,43)
+#define K_F35		K(KT_FN,44)
+#define K_F36		K(KT_FN,45)
+#define K_F37		K(KT_FN,46)
+#define K_F38		K(KT_FN,47)
+#define K_F39		K(KT_FN,48)
+#define K_F40		K(KT_FN,49)
+#define K_F41		K(KT_FN,50)
+#define K_F42		K(KT_FN,51)
+#define K_F43		K(KT_FN,52)
+#define K_F44		K(KT_FN,53)
+#define K_F45		K(KT_FN,54)
+#define K_F46		K(KT_FN,55)
+#define K_F47		K(KT_FN,56)
+#define K_F48		K(KT_FN,57)
+#define K_F49		K(KT_FN,58)
+#define K_F50		K(KT_FN,59)
+#define K_F51		K(KT_FN,60)
+#define K_F52		K(KT_FN,61)
+#define K_F53		K(KT_FN,62)
+#define K_F54		K(KT_FN,63)
+#define K_F55		K(KT_FN,64)
+#define K_F56		K(KT_FN,65)
+#define K_F57		K(KT_FN,66)
+#define K_F58		K(KT_FN,67)
+#define K_F59		K(KT_FN,68)
+#define K_F60		K(KT_FN,69)
+#define K_F61		K(KT_FN,70)
+#define K_F62		K(KT_FN,71)
+#define K_F63		K(KT_FN,72)
+#define K_F64		K(KT_FN,73)
+#define K_F65		K(KT_FN,74)
+#define K_F66		K(KT_FN,75)
+#define K_F67		K(KT_FN,76)
+#define K_F68		K(KT_FN,77)
+#define K_F69		K(KT_FN,78)
+#define K_F70		K(KT_FN,79)
+#define K_F71		K(KT_FN,80)
+#define K_F72		K(KT_FN,81)
+#define K_F73		K(KT_FN,82)
+#define K_F74		K(KT_FN,83)
+#define K_F75		K(KT_FN,84)
+#define K_F76		K(KT_FN,85)
+#define K_F77		K(KT_FN,86)
+#define K_F78		K(KT_FN,87)
+#define K_F79		K(KT_FN,88)
+#define K_F80		K(KT_FN,89)
+#define K_F81		K(KT_FN,90)
+#define K_F82		K(KT_FN,91)
+#define K_F83		K(KT_FN,92)
+#define K_F84		K(KT_FN,93)
+#define K_F85		K(KT_FN,94)
+#define K_F86		K(KT_FN,95)
+#define K_F87		K(KT_FN,96)
+#define K_F88		K(KT_FN,97)
+#define K_F89		K(KT_FN,98)
+#define K_F90		K(KT_FN,99)
+#define K_F91		K(KT_FN,100)
+#define K_F92		K(KT_FN,101)
+#define K_F93		K(KT_FN,102)
+#define K_F94		K(KT_FN,103)
+#define K_F95		K(KT_FN,104)
+#define K_F96		K(KT_FN,105)
+#define K_F97		K(KT_FN,106)
+#define K_F98		K(KT_FN,107)
+#define K_F99		K(KT_FN,108)
+#define K_F100		K(KT_FN,109)
+#define K_F101		K(KT_FN,110)
+#define K_F102		K(KT_FN,111)
+#define K_F103		K(KT_FN,112)
+#define K_F104		K(KT_FN,113)
+#define K_F105		K(KT_FN,114)
+#define K_F106		K(KT_FN,115)
+#define K_F107		K(KT_FN,116)
+#define K_F108		K(KT_FN,117)
+#define K_F109		K(KT_FN,118)
+#define K_F110		K(KT_FN,119)
+#define K_F111		K(KT_FN,120)
+#define K_F112		K(KT_FN,121)
+#define K_F113		K(KT_FN,122)
+#define K_F114		K(KT_FN,123)
+#define K_F115		K(KT_FN,124)
+#define K_F116		K(KT_FN,125)
+#define K_F117		K(KT_FN,126)
+#define K_F118		K(KT_FN,127)
+#define K_F119		K(KT_FN,128)
+#define K_F120		K(KT_FN,129)
+#define K_F121		K(KT_FN,130)
+#define K_F122		K(KT_FN,131)
+#define K_F123		K(KT_FN,132)
+#define K_F124		K(KT_FN,133)
+#define K_F125		K(KT_FN,134)
+#define K_F126		K(KT_FN,135)
+#define K_F127		K(KT_FN,136)
+#define K_F128		K(KT_FN,137)
+#define K_F129		K(KT_FN,138)
+#define K_F130		K(KT_FN,139)
+#define K_F131		K(KT_FN,140)
+#define K_F132		K(KT_FN,141)
+#define K_F133		K(KT_FN,142)
+#define K_F134		K(KT_FN,143)
+#define K_F135		K(KT_FN,144)
+#define K_F136		K(KT_FN,145)
+#define K_F137		K(KT_FN,146)
+#define K_F138		K(KT_FN,147)
+#define K_F139		K(KT_FN,148)
+#define K_F140		K(KT_FN,149)
+#define K_F141		K(KT_FN,150)
+#define K_F142		K(KT_FN,151)
+#define K_F143		K(KT_FN,152)
+#define K_F144		K(KT_FN,153)
+#define K_F145		K(KT_FN,154)
+#define K_F146		K(KT_FN,155)
+#define K_F147		K(KT_FN,156)
+#define K_F148		K(KT_FN,157)
+#define K_F149		K(KT_FN,158)
+#define K_F150		K(KT_FN,159)
+#define K_F151		K(KT_FN,160)
+#define K_F152		K(KT_FN,161)
+#define K_F153		K(KT_FN,162)
+#define K_F154		K(KT_FN,163)
+#define K_F155		K(KT_FN,164)
+#define K_F156		K(KT_FN,165)
+#define K_F157		K(KT_FN,166)
+#define K_F158		K(KT_FN,167)
+#define K_F159		K(KT_FN,168)
+#define K_F160		K(KT_FN,169)
+#define K_F161		K(KT_FN,170)
+#define K_F162		K(KT_FN,171)
+#define K_F163		K(KT_FN,172)
+#define K_F164		K(KT_FN,173)
+#define K_F165		K(KT_FN,174)
+#define K_F166		K(KT_FN,175)
+#define K_F167		K(KT_FN,176)
+#define K_F168		K(KT_FN,177)
+#define K_F169		K(KT_FN,178)
+#define K_F170		K(KT_FN,179)
+#define K_F171		K(KT_FN,180)
+#define K_F172		K(KT_FN,181)
+#define K_F173		K(KT_FN,182)
+#define K_F174		K(KT_FN,183)
+#define K_F175		K(KT_FN,184)
+#define K_F176		K(KT_FN,185)
+#define K_F177		K(KT_FN,186)
+#define K_F178		K(KT_FN,187)
+#define K_F179		K(KT_FN,188)
+#define K_F180		K(KT_FN,189)
+#define K_F181		K(KT_FN,190)
+#define K_F182		K(KT_FN,191)
+#define K_F183		K(KT_FN,192)
+#define K_F184		K(KT_FN,193)
+#define K_F185		K(KT_FN,194)
+#define K_F186		K(KT_FN,195)
+#define K_F187		K(KT_FN,196)
+#define K_F188		K(KT_FN,197)
+#define K_F189		K(KT_FN,198)
+#define K_F190		K(KT_FN,199)
+#define K_F191		K(KT_FN,200)
+#define K_F192		K(KT_FN,201)
+#define K_F193		K(KT_FN,202)
+#define K_F194		K(KT_FN,203)
+#define K_F195		K(KT_FN,204)
+#define K_F196		K(KT_FN,205)
+#define K_F197		K(KT_FN,206)
+#define K_F198		K(KT_FN,207)
+#define K_F199		K(KT_FN,208)
+#define K_F200		K(KT_FN,209)
+#define K_F201		K(KT_FN,210)
+#define K_F202		K(KT_FN,211)
+#define K_F203		K(KT_FN,212)
+#define K_F204		K(KT_FN,213)
+#define K_F205		K(KT_FN,214)
+#define K_F206		K(KT_FN,215)
+#define K_F207		K(KT_FN,216)
+#define K_F208		K(KT_FN,217)
+#define K_F209		K(KT_FN,218)
+#define K_F210		K(KT_FN,219)
+#define K_F211		K(KT_FN,220)
+#define K_F212		K(KT_FN,221)
+#define K_F213		K(KT_FN,222)
+#define K_F214		K(KT_FN,223)
+#define K_F215		K(KT_FN,224)
+#define K_F216		K(KT_FN,225)
+#define K_F217		K(KT_FN,226)
+#define K_F218		K(KT_FN,227)
+#define K_F219		K(KT_FN,228)
+#define K_F220		K(KT_FN,229)
+#define K_F221		K(KT_FN,230)
+#define K_F222		K(KT_FN,231)
+#define K_F223		K(KT_FN,232)
+#define K_F224		K(KT_FN,233)
+#define K_F225		K(KT_FN,234)
+#define K_F226		K(KT_FN,235)
+#define K_F227		K(KT_FN,236)
+#define K_F228		K(KT_FN,237)
+#define K_F229		K(KT_FN,238)
+#define K_F230		K(KT_FN,239)
+#define K_F231		K(KT_FN,240)
+#define K_F232		K(KT_FN,241)
+#define K_F233		K(KT_FN,242)
+#define K_F234		K(KT_FN,243)
+#define K_F235		K(KT_FN,244)
+#define K_F236		K(KT_FN,245)
+#define K_F237		K(KT_FN,246)
+#define K_F238		K(KT_FN,247)
+#define K_F239		K(KT_FN,248)
+#define K_F240		K(KT_FN,249)
+#define K_F241		K(KT_FN,250)
+#define K_F242		K(KT_FN,251)
+#define K_F243		K(KT_FN,252)
+#define K_F244		K(KT_FN,253)
+#define K_F245		K(KT_FN,254)
+#define K_UNDO		K(KT_FN,255)
+
+
+#define K_HOLE		K(KT_SPEC,0)
+#define K_ENTER		K(KT_SPEC,1)
+#define K_SH_REGS	K(KT_SPEC,2)
+#define K_SH_MEM	K(KT_SPEC,3)
+#define K_SH_STAT	K(KT_SPEC,4)
+#define K_BREAK		K(KT_SPEC,5)
+#define K_CONS		K(KT_SPEC,6)
+#define K_CAPS		K(KT_SPEC,7)
+#define K_NUM		K(KT_SPEC,8)
+#define K_HOLD		K(KT_SPEC,9)
+#define K_SCROLLFORW	K(KT_SPEC,10)
+#define K_SCROLLBACK	K(KT_SPEC,11)
+#define K_BOOT		K(KT_SPEC,12)
+#define K_CAPSON	K(KT_SPEC,13)
+#define K_COMPOSE	K(KT_SPEC,14)
+#define K_SAK		K(KT_SPEC,15)
+#define K_DECRCONSOLE	K(KT_SPEC,16)
+#define K_INCRCONSOLE	K(KT_SPEC,17)
+#define K_SPAWNCONSOLE	K(KT_SPEC,18)
+#define K_BARENUMLOCK	K(KT_SPEC,19)
+
+#define K_ALLOCATED	K(KT_SPEC,126) /* dynamically allocated keymap */
+#define K_NOSUCHMAP	K(KT_SPEC,127) /* returned by KDGKBENT */
+
+#define K_P0		K(KT_PAD,0)
+#define K_P1		K(KT_PAD,1)
+#define K_P2		K(KT_PAD,2)
+#define K_P3		K(KT_PAD,3)
+#define K_P4		K(KT_PAD,4)
+#define K_P5		K(KT_PAD,5)
+#define K_P6		K(KT_PAD,6)
+#define K_P7		K(KT_PAD,7)
+#define K_P8		K(KT_PAD,8)
+#define K_P9		K(KT_PAD,9)
+#define K_PPLUS		K(KT_PAD,10)	/* key-pad plus */
+#define K_PMINUS	K(KT_PAD,11)	/* key-pad minus */
+#define K_PSTAR		K(KT_PAD,12)	/* key-pad asterisk (star) */
+#define K_PSLASH	K(KT_PAD,13)	/* key-pad slash */
+#define K_PENTER	K(KT_PAD,14)	/* key-pad enter */
+#define K_PCOMMA	K(KT_PAD,15)	/* key-pad comma: kludge... */
+#define K_PDOT		K(KT_PAD,16)	/* key-pad dot (period): kludge... */
+#define K_PPLUSMINUS	K(KT_PAD,17)	/* key-pad plus/minus */
+#define K_PPARENL	K(KT_PAD,18)	/* key-pad left parenthesis */
+#define K_PPARENR	K(KT_PAD,19)	/* key-pad right parenthesis */
+
+#define NR_PAD		20
+
+#define K_DGRAVE	K(KT_DEAD,0)
+#define K_DACUTE	K(KT_DEAD,1)
+#define K_DCIRCM	K(KT_DEAD,2)
+#define K_DTILDE	K(KT_DEAD,3)
+#define K_DDIERE	K(KT_DEAD,4)
+#define K_DCEDIL	K(KT_DEAD,5)
+
+#define NR_DEAD		6
+
+#define K_DOWN		K(KT_CUR,0)
+#define K_LEFT		K(KT_CUR,1)
+#define K_RIGHT		K(KT_CUR,2)
+#define K_UP		K(KT_CUR,3)
+
+#define K_SHIFT		K(KT_SHIFT,KG_SHIFT)
+#define K_CTRL		K(KT_SHIFT,KG_CTRL)
+#define K_ALT		K(KT_SHIFT,KG_ALT)
+#define K_ALTGR		K(KT_SHIFT,KG_ALTGR)
+#define K_SHIFTL	K(KT_SHIFT,KG_SHIFTL)
+#define K_SHIFTR	K(KT_SHIFT,KG_SHIFTR)
+#define K_CTRLL	 	K(KT_SHIFT,KG_CTRLL)
+#define K_CTRLR	 	K(KT_SHIFT,KG_CTRLR)
+#define K_CAPSSHIFT	K(KT_SHIFT,KG_CAPSSHIFT)
+
+#define K_ASC0		K(KT_ASCII,0)
+#define K_ASC1		K(KT_ASCII,1)
+#define K_ASC2		K(KT_ASCII,2)
+#define K_ASC3		K(KT_ASCII,3)
+#define K_ASC4		K(KT_ASCII,4)
+#define K_ASC5		K(KT_ASCII,5)
+#define K_ASC6		K(KT_ASCII,6)
+#define K_ASC7		K(KT_ASCII,7)
+#define K_ASC8		K(KT_ASCII,8)
+#define K_ASC9		K(KT_ASCII,9)
+#define K_HEX0		K(KT_ASCII,10)
+#define K_HEX1		K(KT_ASCII,11)
+#define K_HEX2		K(KT_ASCII,12)
+#define K_HEX3		K(KT_ASCII,13)
+#define K_HEX4		K(KT_ASCII,14)
+#define K_HEX5		K(KT_ASCII,15)
+#define K_HEX6		K(KT_ASCII,16)
+#define K_HEX7		K(KT_ASCII,17)
+#define K_HEX8		K(KT_ASCII,18)
+#define K_HEX9		K(KT_ASCII,19)
+#define K_HEXa		K(KT_ASCII,20)
+#define K_HEXb		K(KT_ASCII,21)
+#define K_HEXc		K(KT_ASCII,22)
+#define K_HEXd		K(KT_ASCII,23)
+#define K_HEXe		K(KT_ASCII,24)
+#define K_HEXf		K(KT_ASCII,25)
+
+#define NR_ASCII	26
+
+#define K_SHIFTLOCK	K(KT_LOCK,KG_SHIFT)
+#define K_CTRLLOCK	K(KT_LOCK,KG_CTRL)
+#define K_ALTLOCK	K(KT_LOCK,KG_ALT)
+#define K_ALTGRLOCK	K(KT_LOCK,KG_ALTGR)
+#define K_SHIFTLLOCK	K(KT_LOCK,KG_SHIFTL)
+#define K_SHIFTRLOCK	K(KT_LOCK,KG_SHIFTR)
+#define K_CTRLLLOCK	K(KT_LOCK,KG_CTRLL)
+#define K_CTRLRLOCK	K(KT_LOCK,KG_CTRLR)
+
+#define K_SHIFT_SLOCK	K(KT_SLOCK,KG_SHIFT)
+#define K_CTRL_SLOCK	K(KT_SLOCK,KG_CTRL)
+#define K_ALT_SLOCK	K(KT_SLOCK,KG_ALT)
+#define K_ALTGR_SLOCK	K(KT_SLOCK,KG_ALTGR)
+#define K_SHIFTL_SLOCK	K(KT_SLOCK,KG_SHIFTL)
+#define K_SHIFTR_SLOCK	K(KT_SLOCK,KG_SHIFTR)
+#define K_CTRLL_SLOCK	K(KT_SLOCK,KG_CTRLL)
+#define K_CTRLR_SLOCK	K(KT_SLOCK,KG_CTRLR)
+
+#define NR_LOCK		8
+
+#define MAX_DIACR	256
+#endif
Index: b/src/vgamisc.c
===================================================================
--- a/src/vgamisc.c
+++ b/src/vgamisc.c
@@ -73,8 +73,7 @@ unsigned char *
     return __svgalib_graph_mem;
 }
 
-#include <syscall.h>
-#include <linux/kernel.h>
+#include <sys/sysinfo.h>
 
 int __svgalib_physmem(void)
 {
@@ -84,7 +83,7 @@ int __svgalib_physmem(void)
 #else
     struct sysinfo si;
     si.totalram = 0;
-    syscall(SYS_sysinfo, &si);
+    sysinfo(&si);
     return si.totalram;
 #endif
 }
