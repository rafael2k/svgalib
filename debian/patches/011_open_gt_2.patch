Index: b/src/gvga6400.c
===================================================================
--- a/src/gvga6400.c
+++ b/src/gvga6400.c
@@ -178,7 +178,31 @@ static int gvga6400_test(void)
     int result = 0;
     int address;
 
+    /*  Ensure that this open gets a file descriptor greater
+     *  than 2, else problems can occur with stdio functions
+     *  under certain strange conditions:  */
+    if ((fcntl(0,F_GETFD) == -1) && (open("/dev/null", O_RDONLY) == -1)) {
+        perror("/dev/null");
+        exit(1);
+    }
+    if ((fcntl(1,F_GETFD) == -1) && (open("/dev/null", O_WRONLY) == -1)) {
+        perror("/dev/null");
+        exit(1);
+    }
+    if ((fcntl(2,F_GETFD) == -1) && (open("/dev/null", O_WRONLY) == -1)) {
+        perror("/dev/null");
+        exit(1);
+    }
     mem_fd = open("/dev/mem", O_RDONLY);
+    if (mem_fd == -1) {
+        perror("/dev/mem");
+        exit(-1);
+    }
+    /*  Ensure this file is closed if we were ever to exec something else...  */
+    if (fcntl(mem_fd, F_SETFD, 1) == -1) {
+        perror("fcntl");
+        exit(-1);
+    }
 
     /* Changed to use valloc(). */
     if ((vga_bios = valloc(4096)) == NULL) {
Index: b/src/mach32.c
===================================================================
--- a/src/mach32.c
+++ b/src/mach32.c
@@ -1520,9 +1520,18 @@ static int mach32_init(int force, int ch
 	    /*  Ensure that this fopen gets a file descriptor greater
 	     *  than 2, else problems can occur with stdio functions
 	     *  under certain strange conditions:  */
-	    if (fcntl(0,F_GETFD) < 0) open("/dev/null", O_RDONLY);
-	    if (fcntl(1,F_GETFD) < 0) open("/dev/null", O_WRONLY);
-	    if (fcntl(2,F_GETFD) < 0) open("/dev/null", O_WRONLY);
+            if ((fcntl(0,F_GETFD) == -1) && (open("/dev/null", O_RDONLY) == -1)){
+	      /* perror("/dev/null"); */
+	      exit(1);
+            }
+            if ((fcntl(1,F_GETFD) == -1) && (open("/dev/null", O_WRONLY) == -1)){
+	      /* perror("/dev/null"); */
+	      exit(1);
+            }
+            if ((fcntl(2,F_GETFD) == -1) && (open("/dev/null", O_WRONLY) == -1)){
+	      /* perror("/dev/null"); */
+	      exit(1);
+            }
 	    fd = fopen(eeprom_fname, "wb");
 	    if (fd == NULL) {
 	      writerr:
Index: b/src/mouse/ms.c
===================================================================
--- a/src/mouse/ms.c
+++ b/src/mouse/ms.c
@@ -427,6 +427,22 @@ static int ms_init(void)
     if (fcntl(1,F_GETFD) < 0) open("/dev/null", O_WRONLY);
     if (fcntl(2,F_GETFD) < 0) open("/dev/null", O_WRONLY);
 
+    /*  Ensure that the open will get a file descriptor greater
+     *  than 2, else problems can occur with stdio functions
+     *  under certain strange conditions:  */
+    if ((fcntl(0,F_GETFD) == -1) && (open("/dev/null", O_RDONLY) == -1) ) {
+       perror("/dev/null");
+       exit(1);
+    }
+    if ((fcntl(1,F_GETFD) == -1) && (open("/dev/null", O_WRONLY) == -1) ) {
+       perror("/dev/null");
+       exit(1);
+    }
+    if ((fcntl(2,F_GETFD) == -1) && (open("/dev/null", O_WRONLY) == -1) ) {
+       perror("/dev/null");
+       exit(1);
+    }
+
     /* Set the proper wheel delta */
     if(m_wheel_steps)
         m_wheel_delta = (360 / m_wheel_steps);
Index: b/src/vga.c
===================================================================
--- a/src/vga.c
+++ b/src/vga.c
@@ -841,15 +841,48 @@ static void open_mem(void)
     /*  Ensure that the open will get a file descriptor greater
      *  than 2, else problems can occur with stdio functions
      *  under certain strange conditions:  */
-    if (fcntl(0,F_GETFD) < 0) open("/dev/null", O_RDONLY);
-    if (fcntl(1,F_GETFD) < 0) open("/dev/null", O_WRONLY);
-    if (fcntl(2,F_GETFD) < 0) open("/dev/null", O_WRONLY);
+    if ((fcntl(0,F_GETFD) == -1) && (open("/dev/null", O_RDONLY) == -1)){
+      /* perror("/dev/null"); */
+      exit(1);
+    }
+    if ((fcntl(1,F_GETFD) == -1) && (open("/dev/null", O_WRONLY) == -1)){
+      /* perror("/dev/null"); */
+      exit(1);
+    }
+    if ((fcntl(2,F_GETFD) == -1) && (open("/dev/null", O_WRONLY) == -1)){
+      /* perror("/dev/null"); */
+      exit(1);
+    }
+
+    /*
+     * we now use -1 for "not opened" and -2 for "opened and closed
+     * again", to avoid the problems with zgv where this routine is
+     * called after the descriptor has been opened and then closed again.
+     * I don't know why this happens, but we certainly don't want to
+     * re-open it and leave it lying around ...
+     *
+     * This isn't an issue for stock svgalib, which just leaves
+     * __svgalib_mem_fd set to the now-closed descriptor.  But with
+     * Debian's addition of the close-on-exec flag below, we do need to
+     * know whether we expect this to be open or not.
+     *
+     *   -- ASM 30/08/99
+     */
 
-    if (__svgalib_mem_fd < 0)
+    if (__svgalib_mem_fd == -1)
 	if ((__svgalib_mem_fd = open("/dev/mem", O_RDWR)) < 0) {
 	    printf("svgalib: Cannot open /dev/mem.\n");
 	    exit(1);
 	}
+
+    /*  Ensure this file is closed if we ever exec something else...  */
+    if (__svgalib_mem_fd >= 0) {
+      if (fcntl(__svgalib_mem_fd, F_SETFD, 1) == -1) {
+	perror("fcntl 808");
+	exit(-1);
+      }
+    }
+
 #ifdef BACKGROUND
 #if BACKGROUND == 1
 
@@ -866,6 +899,12 @@ static void open_mem(void)
 	          __svgalib_processnumber);
 	      exit(-1);
 	     }
+        /*  Ensure this file is closed if we ever exec something else...  */
+        if (fcntl(__svgalib_mem_fd, F_SETFD, 1) == -1)
+	    {
+            perror("fcntl 831");
+            exit(-1);
+	    }
 	}
 #endif
 #endif
@@ -902,9 +941,18 @@ void __svgalib_open_devconsole(void)
 
     /*  The code below assumes file descriptors 0, 1, and 2
      *  are already open; make sure that's true.  */
-    if (fcntl(0,F_GETFD) < 0) open("/dev/null", O_RDONLY);
-    if (fcntl(1,F_GETFD) < 0) open("/dev/null", O_WRONLY);
-    if (fcntl(2,F_GETFD) < 0) open("/dev/null", O_WRONLY);
+    if ( (fcntl(0,F_GETFD) == -1) && (open("/dev/null", O_RDONLY) == -1) ) {
+       perror("/dev/null");
+       exit(1);
+    }
+    if ( (fcntl(1,F_GETFD) == -1) && (open("/dev/null", O_WRONLY) == -1) ) {
+       perror("/dev/null");
+       exit(1);
+    }
+    if ( (fcntl(2,F_GETFD) == -1) && (open("/dev/null", O_WRONLY) == -1) ) {
+       perror("/dev/null");
+       exit(1);
+    }
 
     /*
      * Now, it would be great if we could use /dev/tty and see what it is connected to.
@@ -924,8 +972,8 @@ void __svgalib_open_devconsole(void)
         return;                 /* perfect */
     }
 
-    if ((__svgalib_tty_fd = open("/dev/console", O_RDWR)) < 0) {
-        printf("svgalib: can't open /dev/console \n");
+    if ((__svgalib_tty_fd = open("/dev/tty0", O_RDWR)) < 0) {
+        printf("svgalib: can't open /dev/tty0 \n");
         exit(1);
     }
     if (ioctl(__svgalib_tty_fd, VT_OPENQRY, &svgalib_vc) < 0)
@@ -4317,7 +4365,24 @@ int vga_initf(int flags) {
 
 int vga_init(void)
 {
-    int retval = 0;
+    int retval = -1;
+
+    /*
+     *	Make sure we know where our stdout/stderr are going
+     *  (based on code by Kevin Vajk)
+     */
+
+    if(fcntl(0, F_GETFD)<0)
+	if(open("/dev/null", O_RDWR, 0)<0)
+    		goto bail;
+    if(fcntl(1, F_GETFD)<0)
+	if(open("/dev/null", O_RDWR, 0)<0)
+    		goto bail;
+    if(fcntl(2, F_GETFD)<0)
+	if(open("/dev/null", O_RDWR, 0)<0)
+    		goto bail;
+
+    retval = 0;
 
 #if 0
     __svgalib_open_devconsole();
@@ -4379,6 +4444,14 @@ if(B8000_MEM_POINTER==NULL){
    
     close(__svgalib_mem_fd);
 
+    /* ASM 30/08/99: Not quite sure what's going on here, but it is
+       possible to call open_mem after this FD is closed now, and this
+       breaks Debian's addition of the set-close-on-exec flag at the
+       end of open_mem if it thinks the FD is still open.  But we
+       can't set it to -1, or it will just be opened again, which is
+       presumably not the idea if it's been explicitly closed here! */
+    __svgalib_mem_fd=-2;
+   
 #ifdef DEBUG
 	    printf("svgalib: Opening mouse (type = %x).\n", mouse_type | mouse_modem_ctl);
 #endif
@@ -4389,6 +4462,7 @@ if(B8000_MEM_POINTER==NULL){
 
     /* Michael: I assume this is a misunderstanding, when svgalib was developed,
        there were no saved uids, thus setting effective uid sufficed... */
+bail:
     if ( __svgalib_security_revokeallprivs == 1 ) {
 	setuid(getuid());  
 	setgid(getgid());
